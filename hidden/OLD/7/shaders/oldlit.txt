#version 330 core

#subtype SUBTYPE_DIR
#subtype SUBTYPE_POINT
#subtype SUBTYPE_SPOT
#subtype SUBTYPE_CSM

#quality QUALITY_LOW
#quality QUALITY_MEDIUM
#quality QUALITY_HIGH
#quality QUALITY_ULTRA

#if QUALITY_LOW
#define SHADOW_SAMPLES 4
#define SHADOW_POINT_SKIP 5
#elif QUALITY_MEDIUM
#define SHADOW_SAMPLES 8
#define SHADOW_POINT_SKIP 4
#elif QUALITY_HIGH
#define SHADOW_SAMPLES 8
#define SHADOW_POINT_SKIP 2
#elif QUALITY_ULTRA
#define SHADOW_SAMPLES 16
#define SHADOW_POINT_SKIP 1
#endif // QUALITY_LOW

in vec3 v_vecFragPos;
in float v_flClipSpacePosZ;
in vec3 v_vecNormal;
in vec3 v_vecTangentLightPos;
in vec3 v_vecTangentViewPos;
in vec3 v_vecTangentFragPos;
in vec2 v_vecTexCoords;
#if !SUBTYPE_POINT
#if SUBTYPE_CSM
in vec4 v_vecFragPosLightSpace[4];
#else // SUBTYPE_CSM
in vec4 v_vecFragPosLightSpace;
#endif // SUBTYPE_CSM
#endif // !SUBTYPE_POINT

layout (std140) uniform lightBuffer
{
	vec3 lightAmbient;
	vec3 lightDiffuse;
	vec3 lightSpecular;
	vec3 lightDirection;
	vec3 lightPosition;
	float lightConstant;
	float lightLinear;
	float lightQuadratic;
	float lightCutOff;
	float lightOuterCutOff;
	bool castShadows;
};

layout (std140) uniform shadowBuffer
{
	mat4 lightSpaceMatrix[6];
	vec4 cascadeEndClipSpaceNear;
	vec4 cascadeEndClipSpaceFar;
	vec4 blurScale;
	float farPlane;
	int numCascades;
};

uniform sampler2D diffuse;
uniform bool useSpecular;
uniform sampler2D specular;
uniform bool useNormal;
uniform sampler2D normalMap;
uniform float shininess;
#if SUBTYPE_POINT
uniform samplerCubeShadow shadowMap;
#elif SUBTYPE_CSM
uniform sampler2DShadow shadowMap[4];
#else
uniform sampler2DShadow shadowMap;
#endif // SUBTYPE_POINT

out vec4 FragColor;

float InterleavedGradientNoise(vec2 screenPos)
{
	vec2 magic = vec2(0.06711056, 0.00583715);
	return fract(52.9829189 * fract(dot(screenPos, magic)));
}

vec2 VogelDiskSample(int sampleIndex, int samplesCount, float phi, int shadowMapIndex)
{
	float r = sqrt(sampleIndex + 0.5) / sqrt(samplesCount) * blurScale[shadowMapIndex];
	float theta = sampleIndex * 2.39996322972865332f + phi;

	return vec2(r * sin(theta), r * cos(theta));
}

#if SUBTYPE_DIR
float ShadowCalculation(void)
{
	float bias = max(0.0003f * (1.0f - dot(-lightDirection, Normal)), 0.0001f);
#if QUALITY_ULTRA || QUALITY_HIGH
	float phi = InterleavedGradientNoise(fract(FragPos.xy * FragPos.yz) * 10000.0f) * 6.2831853071f;
#else // QUALITY_ULTRA || QUALITY_HIGH
	float phi = 0.0f;
#endif // QUALITY_ULTRA || QUALITY_HIGH
		
	vec3 projCoords = (FragPosLightSpace.xyz / FragPosLightSpace.w) * 0.5f + 0.5f;
	if (projCoords.z > 1.0f)
		return 1.0f;

	float shadow = 0.0f;
	for (int i = 0; i < SHADOW_SAMPLES; i++)
		shadow += texture(shadowMap, vec3(projCoords.xy + VogelDiskSample(i, SHADOW_SAMPLES, phi, 0), projCoords.z));
	
	return shadow / float(SHADOW_SAMPLES);
}
#elif SUBTYPE_POINT
mat2 rmat(float r)
{
    float c = cos(r);
    float s = sin(r);
    return mat2(c, s, -s, c);
}

float FragToLightToDepth(vec3 fragToLight)
{
	vec3 absFragToLight = abs(fragToLight);
    return ((farPlane + 0.1f) / (farPlane - 0.1f) - (2.0f * farPlane * 0.1f) / (farPlane - 0.1f) / max(absFragToLight.x, max(absFragToLight.y, absFragToLight.z)) + 1.0f) * 0.5f;
}

float ShadowCalculation(void)
{
	vec3 fragToLight = FragPos - lightPosition;
	float phi = InterleavedGradientNoise(fract(FragPos.xy * FragPos.yz) * 10000.0f) * 6.2831853071f;
	
	float shadow = 0.0f;
	for (int i = 0; i < SHADOW_SAMPLES; i++)
	{
		vec3 fragToLightOffset = fragToLight;
		vec2 vogelOffset = VogelDiskSample(i, SHADOW_SAMPLES, phi, 0);
		fragToLightOffset.yz *= rmat(vogelOffset.y);
		fragToLightOffset.xz *= rmat(vogelOffset.x);
		
		shadow += texture(shadowMap, vec4(fragToLightOffset, FragToLightToDepth(fragToLightOffset) - 0.0001f));
	}
	
	return shadow / float(SHADOW_SAMPLES);
	
}
#elif SUBTYPE_SPOT
float ShadowCalculation(void)
{
#if QUALITY_ULTRA || QUALITY_HIGH
	float phi = InterleavedGradientNoise(fract(FragPos.xy * FragPos.yz) * 10000.0f) * 6.2831853071f;
#else // QUALITY_ULTRA || QUALITY_HIGH
	float phi = 0.0f;
#endif // QUALITY_ULTRA || QUALITY_HIGH
		
	vec3 projCoords = (FragPosLightSpace.xyz / FragPosLightSpace.w) * 0.5f + 0.5f;
	float depth = length(FragPos - lightPosition) / farPlane;
	if (projCoords.z > 1.0f)
		return 0.0f;

	float shadow = 0.0f;
	for (int i = 0; i < SHADOW_SAMPLES; i++)
		shadow += texture(shadowMap, vec3(projCoords.xy + VogelDiskSample(i, SHADOW_SAMPLES, phi, 0), depth - 0.005f));
	
	return shadow / float(SHADOW_SAMPLES);
}
#elif SUBTYPE_CSM
float SampleShadowMap(vec2 coords, float compare, float bias, float phi, int shadowMapIndex)
{
	float shadow = 0.0f;
	for (int i = 0; i < SHADOW_SAMPLES; i++)
		shadow += texture(shadowMap[shadowMapIndex], vec3(coords + VogelDiskSample(i, SHADOW_SAMPLES, phi, shadowMapIndex), compare - bias));
	
	return shadow / float(SHADOW_SAMPLES);
}

float ShadowCalculationHelper(float bias, float phi, int numCascadesHelper)
{
	for (int i = 0 ; i < numCascadesHelper; i++)
	{
		if (ClipSpacePosZ <= cascadeEndClipSpaceFar[i])
		{
			vec3 projCoords = (FragPosLightSpace[i].xyz / FragPosLightSpace[i].w) * 0.5f + 0.5f;
			
			float shadow = SampleShadowMap(projCoords.xy, projCoords.z, bias, phi, i);
			if (cascadeEndClipSpaceNear[i] < cascadeEndClipSpaceFar[i] && i < numCascadesHelper - 1 && ClipSpacePosZ > cascadeEndClipSpaceNear[i])
			{
				vec3 projCoordsNext = (FragPosLightSpace[i + 1].xyz / FragPosLightSpace[i + 1].w) * 0.5f + 0.5f;
				shadow = mix(shadow, SampleShadowMap(projCoordsNext.xy, projCoordsNext.z, bias, phi, i + 1), (ClipSpacePosZ - cascadeEndClipSpaceNear[i]) / (cascadeEndClipSpaceFar[i] - cascadeEndClipSpaceNear[i]));
			}
			
			return shadow;
		}
	}
	
	return 1.0f;
}

float ShadowCalculation(void)
{
#if QUALITY_ULTRA || QUALITY_HIGH
	float phi = InterleavedGradientNoise(fract(FragPos.xy * FragPos.yz) * 10000.0f) * 6.2831853071f;
#else // QUALITY_ULTRA || QUALITY_HIGH
	float phi = 0.0f;
#endif // QUALITY_ULTRA || QUALITY_HIGH

	switch (numCascades)
	{
	case 2:
		return ShadowCalculationHelper(0.0001f, phi, 2);
	case 3:
		return ShadowCalculationHelper(0.0001f, phi, 3);
	case 4:
		return ShadowCalculationHelper(0.0001f, phi, 4);
	}
	
	return 1.0f;
}
#endif // SUBTYPE_DIR

void main()
{
	vec3 sampledDiffuse = texture(diffuse, texCoords).xyz;
	
	vec3 normal = useNormal ? normalize(texture(normalMap, texCoords).rgb * 2.0f - 1.0f) * vec3(1.0f, -1.0f, 1.0f) : vec3(0.0f, 0.0f, 1.0f);
	vec3 lightDir = normalize(TangentLightPos - TangentFragPos);
	vec3 viewDir = normalize(TangentViewPos - TangentFragPos);
	
#if SUBTYPE_POINT || SUBTYPE_SPOT
	vec3 delta = lightPosition - FragPos;
	float distance = length(delta);
	float attenuation = 1.0f / ((lightConstant + lightLinear * distance + lightQuadratic * distance * distance));
#if SUBTYPE_SPOT
	attenuation *= clamp((dot(delta / distance, -lightDirection) - lightOuterCutOff) / (lightOuterCutOff - lightCutOff), 0.0f, 1.0f);
#endif // SUBTYPE_SPOT
	
	vec3 ambientLight = lightAmbient * sampledDiffuse * attenuation;
	vec3 diffuseLight = lightDiffuse * max(dot(normal, lightDir), 0.0f) * sampledDiffuse * attenuation;
	vec3 specularLight = useSpecular ? lightSpecular * pow(max(dot(normal, (lightDir + viewDir) * 0.5f), 0.0f), shininess) * texture(specular, texCoords).xyz * attenuation : vec3(0.0f);
#else // SUBTYPE_POINT || SUBTYPE_SPOT
	vec3 ambientLight = lightAmbient * sampledDiffuse;
	
	//if (dot(-lightDirection, Normal) < -0.00001f)
	//{
	//	FragColor = vec4(ambientLight, 1.0f);
	//	return;
	//}
	
	vec3 diffuseLight = lightDiffuse * max(dot(normal, lightDir), 0.0f) * sampledDiffuse;
	vec3 specularLight = useSpecular ? lightSpecular * pow(max(dot(normal, (lightDir + viewDir) * 0.5f), 0.0f), shininess) * texture(specular, texCoords).xyz : vec3(0.0f);
#endif // SUBTYPE_POINT || SUBTYPE_SPOT
	
	float shadow = castShadows ? ShadowCalculation() : 1.0f;
	
    FragColor = vec4(ambientLight + shadow * (diffuseLight + specularLight), 1.0f);
}